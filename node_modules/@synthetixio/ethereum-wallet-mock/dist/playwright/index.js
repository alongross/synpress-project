import { mnemonicToAccount, privateKeyToAccount } from 'viem/accounts';
import { createRequire } from 'module';
import { readFileSync } from 'fs';
import { test } from '@playwright/test';

// src/playwright/EthereumWalletMock.ts

// src/constants.ts
var SEED_PHRASE = "test test test test test test test test test test test junk";
var BLOCKCHAIN = "ethereum";
var ACCOUNT_MOCK = "0xd73b04b0e696b0945283defa3eee453814758f1a";

// src/type/EthereumWalletMockAbstract.ts
var EthereumWalletMockAbstract = class {
  seedPhrase;
  wallet;
  constructor(wallet = "metamask") {
    this.wallet = wallet;
  }
};

// src/playwright/utils/mockEthereum.ts
function mockEthereum(wallet = "metamask", accounts = []) {
  Web3Mock.mock({
    blockchain: "ethereum",
    wallet,
    accounts: {
      return: accounts
    }
  });
}
var require2 = createRequire(import.meta.url);
var PRIVATE_KEY = "ea084c575a01e2bbefcca3db101eaeab1d8af15554640a510c73692db24d0a6a";
var DEFAULT_NETWORK_ID = "0xa";
var web3MockPath = require2.resolve("@depay/web3-mock/dist/umd/index.bundle.js");

// src/playwright/EthereumWalletMock.ts
var EthereumWalletMock = class extends EthereumWalletMockAbstract {
  /** The Playwright Page object to interact with. */
  page;
  /**
   * Creates an instance of EthereumWalletMock.
   * @param page - The Playwright Page object to interact with.
   * @param wallet - The type of wallet to mock.
   */
  constructor(page, wallet = "metamask") {
    super(wallet);
    this.page = page;
    this.wallet = wallet;
  }
  /**
   * Imports a wallet using the given seed phrase.
   * @param seedPhrase - The seed phrase to import.
   * @returns A promise that resolves when the wallet is imported.
   */
  importWallet(seedPhrase) {
    this.seedPhrase = seedPhrase;
    return this.page.evaluate(
      ([blockchain, wallet, accounts]) => {
        class WalletConnectStub {
        }
        let connector;
        if (wallet === "walletconnect") {
          connector = WalletConnectStub;
        }
        return Web3Mock.mock({
          blockchain,
          wallet,
          accounts: {
            return: accounts
          },
          connector
        });
      },
      [BLOCKCHAIN, this.wallet, [ACCOUNT_MOCK]]
    );
  }
  /**
   * Retrieves all account addresses.
   * @returns A promise that resolves to an array of account addresses.
   */
  async getAllAccounts() {
    return this.page.evaluate(() => {
      return window.ethereum.request({ method: "eth_requestAccounts" });
    });
  }
  /**
   * Adds a new account based on the initially imported seed phrase.
   * @returns A promise that resolves when the new account is added.
   */
  async addNewAccount() {
    const accounts = await this.getAllAccounts();
    const newAccount = mnemonicToAccount(this.seedPhrase || "", {
      accountIndex: accounts?.length
    });
    return this.page.evaluate(
      ([blockchain, wallet, accounts2]) => {
        return Web3Mock.mock({
          blockchain,
          wallet,
          accounts: {
            return: accounts2
          }
        });
      },
      [BLOCKCHAIN, this.wallet, [newAccount.address, ...accounts || []]]
    );
  }
  /**
   * Imports a wallet using the given private key.
   * @param privateKey - The private key to import.
   * @returns A promise that resolves when the wallet is imported.
   */
  async importWalletFromPrivateKey(privateKey) {
    const newAccount = privateKeyToAccount(privateKey);
    return this.page.evaluate(
      ([blockchain, wallet, account]) => {
        return Web3Mock.mock({
          blockchain,
          wallet,
          accounts: {
            return: account
          }
        });
      },
      [BLOCKCHAIN, this.wallet, [newAccount.address]]
    );
  }
  /**
   * Switches to the account with the given address.
   * @param accountAddress - The address of the account to switch to.
   * @returns A promise that resolves when the account switch is complete.
   */
  async switchAccount(accountAddress) {
    return this.page.evaluate(
      ([blockchain, wallet, accountAddress2]) => {
        return Web3Mock.mock({
          blockchain,
          wallet,
          accounts: {
            return: [accountAddress2]
          }
        });
      },
      [BLOCKCHAIN, this.wallet, accountAddress]
    );
  }
  /**
   * Adds a new network.
   * @param network - The network object to use for adding the new network.
   * @returns A promise that resolves when the network is added.
   */
  async addNetwork(network) {
    const networkInfo = {
      chainId: network.chainId,
      chainName: network.name,
      nativeCurrency: network.nativeCurrency,
      rpcUrls: [network.rpcUrl],
      blockExplorerUrls: [network.blockExplorerUrl]
    };
    return this.page.evaluate(
      ([blockchain, wallet, networkInfo2]) => {
        return Web3Mock.mock({
          blockchain,
          wallet,
          network: {
            add: networkInfo2
          }
        });
      },
      [BLOCKCHAIN, this.wallet, networkInfo]
    );
  }
  /**
   * Retrieves the current account address.
   * @returns A promise that resolves to the current account address.
   */
  async getAccountAddress() {
    return (await this.getAllAccounts())?.[0];
  }
  /**
   * Switches to the network with the given name.
   * @param networkName - The name of the network to switch to.
   * @returns A promise that resolves when the network switch is complete.
   */
  async switchNetwork(networkName) {
    return this.page.evaluate(
      ([blockchain, wallet, networkName2, chainId]) => {
        Web3Mock.mock({
          blockchain,
          wallet,
          network: {
            switchTo: networkName2
          }
        });
        window.ethereum.request({
          method: "wallet_switchEthereumChain",
          // Mock do not support custom network IDs
          params: [{ chainId }]
        });
      },
      [BLOCKCHAIN, this.wallet, networkName, DEFAULT_NETWORK_ID]
    );
  }
  /**
   * Connects wallet to the dapp.
   * @param wallet - The wallet to connect to the dapp.
   * @returns A promise that resolves when the wallet is connected to the dapp.
   */
  connectToDapp(wallet = "metamask") {
    this.wallet = wallet;
    return this.page.evaluate(
      ([blockchain, accounts, wallet2]) => {
        class WalletConnectStub {
        }
        let connector;
        if (wallet2 === "walletconnect") {
          connector = WalletConnectStub;
        }
        return Web3Mock.mock({
          blockchain,
          wallet: wallet2,
          accounts: {
            return: accounts
          },
          connector
        });
      },
      [BLOCKCHAIN, [ACCOUNT_MOCK], wallet]
    );
  }
};
var ethereumWalletMockFixtures = test.extend({
  context: async ({ context }, use) => {
    await context.addInitScript({
      content: `${readFileSync(web3MockPath, "utf-8")}
(${mockEthereum.toString()})();`
    });
    await use(context);
    await context.close();
  },
  page: async ({ context }, use) => {
    const page = await context.newPage();
    await page.goto("/");
    await use(page);
  },
  ethereumWalletMock: async ({ page }, use) => {
    const ethereumWalletMock = new EthereumWalletMock(page);
    await ethereumWalletMock.importWallet(SEED_PHRASE);
    await use(ethereumWalletMock);
  }
});

export { DEFAULT_NETWORK_ID, EthereumWalletMock, PRIVATE_KEY, ethereumWalletMockFixtures, mockEthereum, web3MockPath };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map