#!/usr/bin/env node
import os, { tmpdir } from 'os';
import path5, { resolve, parse, basename } from 'path';
import chalk from 'chalk';
import { Command } from 'commander';
import { glob, globSync } from 'glob';
import { inspect } from 'util';
import fs, { lstatSync, rmSync, unlinkSync, rmdirSync, renameSync, readdirSync as readdirSync$1, chmodSync, statSync } from 'fs';
import fs7 from 'fs-extra';
import { z } from 'zod';
import { chromium, errors } from 'playwright-core';
import axios from 'axios';
import ProgressBar from 'progress';
import unzippper from 'unzipper';
import 'esbuild';
import { build } from 'tsup';
import gradient from 'gradient-string';

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/opt-arg.js
var typeOrUndef = (val, t) => typeof val === "undefined" || typeof val === t;
var isRimrafOptions = (o) => !!o && typeof o === "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.tmp, "string") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number") && (typeOrUndef(o.glob, "boolean") || o.glob && typeof o.glob === "object") && typeOrUndef(o.filter, "function");
var assertRimrafOptions = (o) => {
  if (!isRimrafOptions(o)) {
    throw new Error("invalid rimraf options");
  }
};
var optArgT = (opt) => {
  assertRimrafOptions(opt);
  const { glob: glob3, ...options } = opt;
  if (!glob3) {
    return options;
  }
  const globOpt = glob3 === true ? opt.signal ? { signal: opt.signal } : {} : opt.signal ? {
    signal: opt.signal,
    ...glob3
  } : glob3;
  return {
    ...options,
    glob: {
      ...globOpt,
      // always get absolute paths from glob, to ensure
      // that we are referencing the correct thing.
      absolute: true,
      withFileTypes: false
    }
  };
};
var optArg = (opt = {}) => optArgT(opt);
var optArgSync = (opt = {}) => optArgT(opt);

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/platform.js
var platform_default = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/path-arg.js
var pathArg = (path8, opt = {}) => {
  const type = typeof path8;
  if (type !== "string") {
    const ctor = path8 && type === "object" && path8.constructor;
    const received = ctor && ctor.name ? `an instance of ${ctor.name}` : type === "object" ? inspect(path8) : `type ${type} ${path8}`;
    const msg = `The "path" argument must be of type string. Received ${received}`;
    throw Object.assign(new TypeError(msg), {
      path: path8,
      code: "ERR_INVALID_ARG_TYPE"
    });
  }
  if (/\0/.test(path8)) {
    const msg = "path must be a string without null bytes";
    throw Object.assign(new TypeError(msg), {
      path: path8,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path8 = resolve(path8);
  const { root } = parse(path8);
  if (path8 === root && opt.preserveRoot !== false) {
    const msg = "refusing to remove root directory without preserveRoot:false";
    throw Object.assign(new Error(msg), {
      path: path8,
      code: "ERR_PRESERVE_ROOT"
    });
  }
  if (platform_default === "win32") {
    const badWinChars = /[*|"<>?:]/;
    const { root: root2 } = parse(path8);
    if (badWinChars.test(path8.substring(root2.length))) {
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path8,
        code: "EINVAL"
      });
    }
  }
  return path8;
};
var path_arg_default = pathArg;
var readdirSync = (path8) => readdirSync$1(path8, { withFileTypes: true });
var chmod = (path8, mode) => new Promise((res, rej) => fs.chmod(path8, mode, (er, ...d) => er ? rej(er) : res(...d)));
var mkdir = (path8, options) => new Promise((res, rej) => fs.mkdir(path8, options, (er, made) => er ? rej(er) : res(made)));
var readdir = (path8) => new Promise((res, rej) => fs.readdir(path8, { withFileTypes: true }, (er, data) => er ? rej(er) : res(data)));
var rename = (oldPath, newPath) => new Promise((res, rej) => fs.rename(oldPath, newPath, (er, ...d) => er ? rej(er) : res(...d)));
var rm = (path8, options) => new Promise((res, rej) => fs.rm(path8, options, (er, ...d) => er ? rej(er) : res(...d)));
var rmdir = (path8) => new Promise((res, rej) => fs.rmdir(path8, (er, ...d) => er ? rej(er) : res(...d)));
var stat = (path8) => new Promise((res, rej) => fs.stat(path8, (er, data) => er ? rej(er) : res(data)));
var lstat = (path8) => new Promise((res, rej) => fs.lstat(path8, (er, data) => er ? rej(er) : res(data)));
var unlink = (path8) => new Promise((res, rej) => fs.unlink(path8, (er, ...d) => er ? rej(er) : res(...d)));
var promises = {
  chmod,
  mkdir,
  readdir,
  rename,
  rm,
  rmdir,
  stat,
  lstat,
  unlink
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/readdir-or-error.js
var { readdir: readdir2 } = promises;
var readdirOrError = (path8) => readdir2(path8).catch((er) => er);
var readdirOrErrorSync = (path8) => {
  try {
    return readdirSync(path8);
  } catch (er) {
    return er;
  }
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/ignore-enoent.js
var ignoreENOENT = async (p) => p.catch((er) => {
  if (er.code !== "ENOENT") {
    throw er;
  }
});
var ignoreENOENTSync = (fn) => {
  try {
    return fn();
  } catch (er) {
    if (er?.code !== "ENOENT") {
      throw er;
    }
  }
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/rimraf-posix.js
var { lstat: lstat2, rmdir: rmdir2, unlink: unlink2 } = promises;
var rimrafPosix = async (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  try {
    return await rimrafPosixDir(path8, opt, await lstat2(path8));
  } catch (er) {
    if (er?.code === "ENOENT")
      return true;
    throw er;
  }
};
var rimrafPosixSync = (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  try {
    return rimrafPosixDirSync(path8, opt, lstatSync(path8));
  } catch (er) {
    if (er?.code === "ENOENT")
      return true;
    throw er;
  }
};
var rimrafPosixDir = async (path8, opt, ent) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  const entries = ent.isDirectory() ? await readdirOrError(path8) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT") {
        return true;
      }
      if (entries.code !== "ENOTDIR") {
        throw entries;
      }
    }
    if (opt.filter && !await opt.filter(path8, ent)) {
      return false;
    }
    await ignoreENOENT(unlink2(path8));
    return true;
  }
  const removedAll = (await Promise.all(entries.map((ent2) => rimrafPosixDir(resolve(path8, ent2.name), opt, ent2)))).reduce((a, b) => a && b, true);
  if (!removedAll) {
    return false;
  }
  if (opt.preserveRoot === false && path8 === parse(path8).root) {
    return false;
  }
  if (opt.filter && !await opt.filter(path8, ent)) {
    return false;
  }
  await ignoreENOENT(rmdir2(path8));
  return true;
};
var rimrafPosixDirSync = (path8, opt, ent) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  const entries = ent.isDirectory() ? readdirOrErrorSync(path8) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT") {
        return true;
      }
      if (entries.code !== "ENOTDIR") {
        throw entries;
      }
    }
    if (opt.filter && !opt.filter(path8, ent)) {
      return false;
    }
    ignoreENOENTSync(() => unlinkSync(path8));
    return true;
  }
  let removedAll = true;
  for (const ent2 of entries) {
    const p = resolve(path8, ent2.name);
    removedAll = rimrafPosixDirSync(p, opt, ent2) && removedAll;
  }
  if (opt.preserveRoot === false && path8 === parse(path8).root) {
    return false;
  }
  if (!removedAll) {
    return false;
  }
  if (opt.filter && !opt.filter(path8, ent)) {
    return false;
  }
  ignoreENOENTSync(() => rmdirSync(path8));
  return true;
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/fix-eperm.js
var { chmod: chmod2 } = promises;
var fixEPERM = (fn) => async (path8) => {
  try {
    return await fn(path8);
  } catch (er) {
    const fer = er;
    if (fer?.code === "ENOENT") {
      return;
    }
    if (fer?.code === "EPERM") {
      try {
        await chmod2(path8, 438);
      } catch (er2) {
        const fer2 = er2;
        if (fer2?.code === "ENOENT") {
          return;
        }
        throw er;
      }
      return await fn(path8);
    }
    throw er;
  }
};
var fixEPERMSync = (fn) => (path8) => {
  try {
    return fn(path8);
  } catch (er) {
    const fer = er;
    if (fer?.code === "ENOENT") {
      return;
    }
    if (fer?.code === "EPERM") {
      try {
        chmodSync(path8, 438);
      } catch (er2) {
        const fer2 = er2;
        if (fer2?.code === "ENOENT") {
          return;
        }
        throw er;
      }
      return fn(path8);
    }
    throw er;
  }
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/retry-busy.js
var MAXBACKOFF = 200;
var RATE = 1.2;
var MAXRETRIES = 10;
var codes = /* @__PURE__ */ new Set(["EMFILE", "ENFILE", "EBUSY"]);
var retryBusy = (fn) => {
  const method = async (path8, opt, backoff = 1, total = 0) => {
    const mbo = opt.maxBackoff || MAXBACKOFF;
    const rate = opt.backoff || RATE;
    const max = opt.maxRetries || MAXRETRIES;
    let retries = 0;
    while (true) {
      try {
        return await fn(path8);
      } catch (er) {
        const fer = er;
        if (fer?.path === path8 && fer?.code && codes.has(fer.code)) {
          backoff = Math.ceil(backoff * rate);
          total = backoff + total;
          if (total < mbo) {
            return new Promise((res, rej) => {
              setTimeout(() => {
                method(path8, opt, backoff, total).then(res, rej);
              }, backoff);
            });
          }
          if (retries < max) {
            retries++;
            continue;
          }
        }
        throw er;
      }
    }
  };
  return method;
};
var retryBusySync = (fn) => {
  const method = (path8, opt) => {
    const max = opt.maxRetries || MAXRETRIES;
    let retries = 0;
    while (true) {
      try {
        return fn(path8);
      } catch (er) {
        const fer = er;
        if (fer?.path === path8 && fer?.code && codes.has(fer.code) && retries < max) {
          retries++;
          continue;
        }
        throw er;
      }
    }
  };
  return method;
};
var { stat: stat2 } = promises;
var isDirSync = (path8) => {
  try {
    return statSync(path8).isDirectory();
  } catch (er) {
    return false;
  }
};
var isDir = (path8) => stat2(path8).then((st) => st.isDirectory(), () => false);
var win32DefaultTmp = async (path8) => {
  const { root } = parse(path8);
  const tmp = tmpdir();
  const { root: tmpRoot } = parse(tmp);
  if (root.toLowerCase() === tmpRoot.toLowerCase()) {
    return tmp;
  }
  const driveTmp = resolve(root, "/temp");
  if (await isDir(driveTmp)) {
    return driveTmp;
  }
  return root;
};
var win32DefaultTmpSync = (path8) => {
  const { root } = parse(path8);
  const tmp = tmpdir();
  const { root: tmpRoot } = parse(tmp);
  if (root.toLowerCase() === tmpRoot.toLowerCase()) {
    return tmp;
  }
  const driveTmp = resolve(root, "/temp");
  if (isDirSync(driveTmp)) {
    return driveTmp;
  }
  return root;
};
var posixDefaultTmp = async () => tmpdir();
var posixDefaultTmpSync = () => tmpdir();
var defaultTmp = platform_default === "win32" ? win32DefaultTmp : posixDefaultTmp;
var defaultTmpSync = platform_default === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync;

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/rimraf-move-remove.js
var { lstat: lstat3, rename: rename2, unlink: unlink3, rmdir: rmdir3, chmod: chmod3 } = promises;
var uniqueFilename = (path8) => `.${basename(path8)}.${Math.random()}`;
var unlinkFixEPERM = async (path8) => unlink3(path8).catch((er) => {
  if (er.code === "EPERM") {
    return chmod3(path8, 438).then(() => unlink3(path8), (er2) => {
      if (er2.code === "ENOENT") {
        return;
      }
      throw er;
    });
  } else if (er.code === "ENOENT") {
    return;
  }
  throw er;
});
var unlinkFixEPERMSync = (path8) => {
  try {
    unlinkSync(path8);
  } catch (er) {
    if (er?.code === "EPERM") {
      try {
        return chmodSync(path8, 438);
      } catch (er2) {
        if (er2?.code === "ENOENT") {
          return;
        }
        throw er;
      }
    } else if (er?.code === "ENOENT") {
      return;
    }
    throw er;
  }
};
var rimrafMoveRemove = async (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  try {
    return await rimrafMoveRemoveDir(path8, opt, await lstat3(path8));
  } catch (er) {
    if (er?.code === "ENOENT")
      return true;
    throw er;
  }
};
var rimrafMoveRemoveDir = async (path8, opt, ent) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  if (!opt.tmp) {
    return rimrafMoveRemoveDir(path8, { ...opt, tmp: await defaultTmp(path8) }, ent);
  }
  if (path8 === opt.tmp && parse(path8).root !== path8) {
    throw new Error("cannot delete temp directory used for deletion");
  }
  const entries = ent.isDirectory() ? await readdirOrError(path8) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT") {
        return true;
      }
      if (entries.code !== "ENOTDIR") {
        throw entries;
      }
    }
    if (opt.filter && !await opt.filter(path8, ent)) {
      return false;
    }
    await ignoreENOENT(tmpUnlink(path8, opt.tmp, unlinkFixEPERM));
    return true;
  }
  const removedAll = (await Promise.all(entries.map((ent2) => rimrafMoveRemoveDir(resolve(path8, ent2.name), opt, ent2)))).reduce((a, b) => a && b, true);
  if (!removedAll) {
    return false;
  }
  if (opt.preserveRoot === false && path8 === parse(path8).root) {
    return false;
  }
  if (opt.filter && !await opt.filter(path8, ent)) {
    return false;
  }
  await ignoreENOENT(tmpUnlink(path8, opt.tmp, rmdir3));
  return true;
};
var tmpUnlink = async (path8, tmp, rm3) => {
  const tmpFile = resolve(tmp, uniqueFilename(path8));
  await rename2(path8, tmpFile);
  return await rm3(tmpFile);
};
var rimrafMoveRemoveSync = (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  try {
    return rimrafMoveRemoveDirSync(path8, opt, lstatSync(path8));
  } catch (er) {
    if (er?.code === "ENOENT")
      return true;
    throw er;
  }
};
var rimrafMoveRemoveDirSync = (path8, opt, ent) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  if (!opt.tmp) {
    return rimrafMoveRemoveDirSync(path8, { ...opt, tmp: defaultTmpSync(path8) }, ent);
  }
  const tmp = opt.tmp;
  if (path8 === opt.tmp && parse(path8).root !== path8) {
    throw new Error("cannot delete temp directory used for deletion");
  }
  const entries = ent.isDirectory() ? readdirOrErrorSync(path8) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT") {
        return true;
      }
      if (entries.code !== "ENOTDIR") {
        throw entries;
      }
    }
    if (opt.filter && !opt.filter(path8, ent)) {
      return false;
    }
    ignoreENOENTSync(() => tmpUnlinkSync(path8, tmp, unlinkFixEPERMSync));
    return true;
  }
  let removedAll = true;
  for (const ent2 of entries) {
    const p = resolve(path8, ent2.name);
    removedAll = rimrafMoveRemoveDirSync(p, opt, ent2) && removedAll;
  }
  if (!removedAll) {
    return false;
  }
  if (opt.preserveRoot === false && path8 === parse(path8).root) {
    return false;
  }
  if (opt.filter && !opt.filter(path8, ent)) {
    return false;
  }
  ignoreENOENTSync(() => tmpUnlinkSync(path8, tmp, rmdirSync));
  return true;
};
var tmpUnlinkSync = (path8, tmp, rmSync2) => {
  const tmpFile = resolve(tmp, uniqueFilename(path8));
  renameSync(path8, tmpFile);
  return rmSync2(tmpFile);
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/rimraf-windows.js
var { unlink: unlink4, rmdir: rmdir4, lstat: lstat4 } = promises;
var rimrafWindowsFile = retryBusy(fixEPERM(unlink4));
var rimrafWindowsFileSync = retryBusySync(fixEPERMSync(unlinkSync));
var rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir4));
var rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(rmdirSync));
var rimrafWindowsDirMoveRemoveFallback = async (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  const { filter, ...options } = opt;
  try {
    return await rimrafWindowsDirRetry(path8, options);
  } catch (er) {
    if (er?.code === "ENOTEMPTY") {
      return await rimrafMoveRemove(path8, options);
    }
    throw er;
  }
};
var rimrafWindowsDirMoveRemoveFallbackSync = (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  const { filter, ...options } = opt;
  try {
    return rimrafWindowsDirRetrySync(path8, options);
  } catch (er) {
    const fer = er;
    if (fer?.code === "ENOTEMPTY") {
      return rimrafMoveRemoveSync(path8, options);
    }
    throw er;
  }
};
var START = Symbol("start");
var CHILD = Symbol("child");
var FINISH = Symbol("finish");
var rimrafWindows = async (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  try {
    return await rimrafWindowsDir(path8, opt, await lstat4(path8), START);
  } catch (er) {
    if (er?.code === "ENOENT")
      return true;
    throw er;
  }
};
var rimrafWindowsSync = (path8, opt) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  try {
    return rimrafWindowsDirSync(path8, opt, lstatSync(path8), START);
  } catch (er) {
    if (er?.code === "ENOENT")
      return true;
    throw er;
  }
};
var rimrafWindowsDir = async (path8, opt, ent, state = START) => {
  if (opt?.signal?.aborted) {
    throw opt.signal.reason;
  }
  const entries = ent.isDirectory() ? await readdirOrError(path8) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT") {
        return true;
      }
      if (entries.code !== "ENOTDIR") {
        throw entries;
      }
    }
    if (opt.filter && !await opt.filter(path8, ent)) {
      return false;
    }
    await ignoreENOENT(rimrafWindowsFile(path8, opt));
    return true;
  }
  const s = state === START ? CHILD : state;
  const removedAll = (await Promise.all(entries.map((ent2) => rimrafWindowsDir(resolve(path8, ent2.name), opt, ent2, s)))).reduce((a, b) => a && b, true);
  if (state === START) {
    return rimrafWindowsDir(path8, opt, ent, FINISH);
  } else if (state === FINISH) {
    if (opt.preserveRoot === false && path8 === parse(path8).root) {
      return false;
    }
    if (!removedAll) {
      return false;
    }
    if (opt.filter && !await opt.filter(path8, ent)) {
      return false;
    }
    await ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path8, opt));
  }
  return true;
};
var rimrafWindowsDirSync = (path8, opt, ent, state = START) => {
  const entries = ent.isDirectory() ? readdirOrErrorSync(path8) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT") {
        return true;
      }
      if (entries.code !== "ENOTDIR") {
        throw entries;
      }
    }
    if (opt.filter && !opt.filter(path8, ent)) {
      return false;
    }
    ignoreENOENTSync(() => rimrafWindowsFileSync(path8, opt));
    return true;
  }
  let removedAll = true;
  for (const ent2 of entries) {
    const s = state === START ? CHILD : state;
    const p = resolve(path8, ent2.name);
    removedAll = rimrafWindowsDirSync(p, opt, ent2, s) && removedAll;
  }
  if (state === START) {
    return rimrafWindowsDirSync(path8, opt, ent, FINISH);
  } else if (state === FINISH) {
    if (opt.preserveRoot === false && path8 === parse(path8).root) {
      return false;
    }
    if (!removedAll) {
      return false;
    }
    if (opt.filter && !opt.filter(path8, ent)) {
      return false;
    }
    ignoreENOENTSync(() => {
      rimrafWindowsDirMoveRemoveFallbackSync(path8, opt);
    });
  }
  return true;
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/rimraf-manual.js
var rimrafManual = platform_default === "win32" ? rimrafWindows : rimrafPosix;
var rimrafManualSync = platform_default === "win32" ? rimrafWindowsSync : rimrafPosixSync;

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/rimraf-native.js
var { rm: rm2 } = promises;
var rimrafNative = async (path8, opt) => {
  await rm2(path8, {
    ...opt,
    force: true,
    recursive: true
  });
  return true;
};
var rimrafNativeSync = (path8, opt) => {
  rmSync(path8, {
    ...opt,
    force: true,
    recursive: true
  });
  return true;
};

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/use-native.js
var version = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version;
var versArr = version.replace(/^v/, "").split(".");
var [major = 0, minor = 0] = versArr.map((v) => parseInt(v, 10));
var hasNative = major > 14 || major === 14 && minor >= 14;
var useNative = !hasNative || platform_default === "win32" ? () => false : (opt) => !opt?.signal && !opt?.filter;
var useNativeSync = !hasNative || platform_default === "win32" ? () => false : (opt) => !opt?.signal && !opt?.filter;

// ../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/dist/esm/index.js
var wrap = (fn) => async (path8, opt) => {
  const options = optArg(opt);
  if (options.glob) {
    path8 = await glob(path8, options.glob);
  }
  if (Array.isArray(path8)) {
    return !!(await Promise.all(path8.map((p) => fn(path_arg_default(p, options), options)))).reduce((a, b) => a && b, true);
  } else {
    return !!await fn(path_arg_default(path8, options), options);
  }
};
var wrapSync = (fn) => (path8, opt) => {
  const options = optArgSync(opt);
  if (options.glob) {
    path8 = globSync(path8, options.glob);
  }
  if (Array.isArray(path8)) {
    return !!path8.map((p) => fn(path_arg_default(p, options), options)).reduce((a, b) => a && b, true);
  } else {
    return !!fn(path_arg_default(path8, options), options);
  }
};
var nativeSync = wrapSync(rimrafNativeSync);
var native = Object.assign(wrap(rimrafNative), { sync: nativeSync });
var manualSync = wrapSync(rimrafManualSync);
var manual = Object.assign(wrap(rimrafManual), { sync: manualSync });
var windowsSync = wrapSync(rimrafWindowsSync);
var windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync });
var posixSync = wrapSync(rimrafPosixSync);
var posix = Object.assign(wrap(rimrafPosix), { sync: posixSync });
var moveRemoveSync = wrapSync(rimrafMoveRemoveSync);
var moveRemove = Object.assign(wrap(rimrafMoveRemove), {
  sync: moveRemoveSync
});
var rimrafSync = wrapSync((path8, opt) => useNativeSync(opt) ? rimrafNativeSync(path8, opt) : rimrafManualSync(path8, opt));
var rimraf_ = wrap((path8, opt) => useNative(opt) ? rimrafNative(path8, opt) : rimrafManual(path8, opt));
var rimraf = Object.assign(rimraf_, {
  rimraf: rimraf_,
  sync: rimrafSync,
  rimrafSync,
  manual,
  manualSync,
  native,
  nativeSync,
  posix,
  posixSync,
  windows,
  windowsSync,
  moveRemove,
  moveRemoveSync
});
rimraf.rimraf = rimraf;

// src/constants.ts
var CACHE_DIR_NAME = ".cache-synpress";
var WALLET_SETUP_DIR_NAME = "wallet-setup";
var SETUP_FILE_FILTER_REGEX = /\.setup\.(ts|js|mjs)$/;
async function getWalletSetupFiles(walletSetupDirPath) {
  await fs7.access(walletSetupDirPath).catch((e) => {
    if (e instanceof Error && e.message.includes("ENOENT")) {
      throw new Error(`[GetWalletSetupFiles] Wallet setup directory does not exist at ${walletSetupDirPath}`);
    }
    throw e;
  });
  const setupFilesFilter = (file) => file.match(SETUP_FILE_FILTER_REGEX);
  const fileList = (await fs7.readdir(walletSetupDirPath)).filter(setupFilesFilter);
  if (!fileList.length) {
    throw new Error(
      [
        `[GetWalletSetupFiles] No wallet setup files found at ${walletSetupDirPath}`,
        "Remember that all wallet setup files must end with `.setup.{ts,js,mjs}` extension!"
      ].join("\n")
    );
  }
  return fileList;
}
var WalletSetupModule = z.object({
  default: z.object({
    hash: z.string(),
    fn: z.function().returns(z.promise(z.void()))
  })
});
async function importWalletSetupFile(walletSetupFilePath) {
  const walletSetupModule = await import(walletSetupFilePath);
  const result = WalletSetupModule.safeParse(walletSetupModule);
  if (!result.success) {
    throw new Error(
      [
        `[ImportWalletSetupFile] Invalid wallet setup function at ${walletSetupFilePath}`,
        "Remember that all wallet setup files must export the wallet setup function as a default export!"
      ].join("\n")
    );
  }
  const { hash, fn } = result.data.default;
  return {
    hash,
    fn
  };
}

// src/utils/getUniqueWalletSetupFunctions.ts
async function getUniqueWalletSetupFunctions(walletSetupDirPath) {
  const fileList = await getWalletSetupFiles(walletSetupDirPath);
  const setupFunctions = /* @__PURE__ */ new Map();
  const duplicatesMap = {};
  for (const fileName of fileList) {
    const walletSetupFilePath = path5.join(walletSetupDirPath, fileName);
    const { hash, fn } = await importWalletSetupFile(walletSetupFilePath);
    const entry = {
      fileName,
      setupFunction: fn
    };
    setupFunctions.set(hash, entry);
    if (duplicatesMap[hash]) {
      duplicatesMap[hash]?.push(entry);
    } else {
      duplicatesMap[hash] = [entry];
    }
  }
  throwIfThereAreDuplicatedHashes(duplicatesMap);
  return setupFunctions;
}
function throwIfThereAreDuplicatedHashes(duplicatesMap) {
  const duplicatedHashes = Object.entries(duplicatesMap).filter(
    ([, setupFunctionsArray]) => setupFunctionsArray.length > 1
  );
  if (duplicatedHashes.length === 0) {
    return;
  }
  const sortedDuplicatedHashes = duplicatedHashes.sort(([hashA], [hashB]) => hashA.localeCompare(hashB));
  throw new Error(
    [
      "[GetUniqueWalletSetupFunctions] There are identical wallet setup functions:",
      sortedDuplicatedHashes.map(([hash, setupFunctionsArray]) => {
        return `	${hash} - [${setupFunctionsArray.map(({ fileName }) => fileName).join(", ")}]`;
      }).join("\n")
    ].join("\n")
  );
}
function ensureCacheDirExists() {
  const cacheDirPath = path5.join(process.cwd(), CACHE_DIR_NAME);
  fs7.ensureDirSync(cacheDirPath);
  return cacheDirPath;
}
async function waitForExtensionOnLoadPage(context) {
  try {
    return await context.waitForEvent("page", { timeout: 5e3 });
  } catch (e) {
    if (e instanceof errors.TimeoutError) {
      throw new Error("[WaitForExtensionOnLoadPage] Extension did not load in time!");
    }
    throw e;
  }
}

// src/utils/createCacheForWalletSetupFunction.ts
var sleep = (ms) => new Promise((resolve6) => setTimeout(resolve6, ms));
async function createCacheForWalletSetupFunction(extensionPath, contextCacheDirPath, walletSetup, fileName) {
  const browserArgs = [`--disable-extensions-except=${extensionPath}`, `--load-extension=${extensionPath}`];
  if (process.env.HEADLESS) {
    browserArgs.push("--headless=new");
  }
  const context = await chromium.launchPersistentContext(contextCacheDirPath, {
    headless: false,
    args: browserArgs
  });
  const extensionPage = await waitForExtensionOnLoadPage(context);
  try {
    await walletSetup(context, extensionPage);
  } catch (e) {
    throw new Error(
      `[CORE] Encountered an error while executing wallet setup function from file ${fileName}. Error message: ${e.message}`
    );
  }
  await sleep(3e3);
  await context.close();
  return;
}
async function isDirEmpty(dirPath) {
  try {
    const files = await fs7.readdir(dirPath);
    return files.length === 0;
  } catch (e) {
    if (e instanceof Error && e.message.includes("ENOENT")) {
      return true;
    }
    throw e;
  }
}

// src/utils/triggerCacheCreation.ts
async function triggerCacheCreation(setupFunctions, downloadExtension, force) {
  const cacheDirPath = ensureCacheDirExists();
  const extensionPath = await downloadExtension();
  const cacheCreationPromises = [];
  for (const [funcHash, { fileName, setupFunction }] of setupFunctions) {
    const cachePath = path5.join(cacheDirPath, funcHash);
    const doesCacheDirExist = await fs7.exists(cachePath);
    const isCacheDirEmpty = await isDirEmpty(cachePath);
    if (doesCacheDirExist) {
      if (isCacheDirEmpty) {
        await fs7.remove(cachePath);
      } else {
        if (!force) {
          console.log(`Cache already exists for ${funcHash}. Skipping...`);
          continue;
        }
        console.log(`Cache already exists for ${funcHash} but force flag is set. Deleting cache...`);
        await fs7.remove(cachePath);
      }
    }
    const fileNameWithCorrectExtension = fileName.replace(/\.(ts|js|mjs)$/, ".{ts,js,mjs}");
    console.log(`Triggering cache creation for: ${funcHash} (${fileNameWithCorrectExtension})`);
    const createCachePromise = createCacheForWalletSetupFunction(
      extensionPath,
      cachePath,
      setupFunction,
      fileNameWithCorrectExtension
    );
    cacheCreationPromises.push(createCachePromise);
  }
  return cacheCreationPromises;
}

// src/createCache.ts
async function createCache(walletSetupDirPath, downloadExtension, force = false) {
  const setupFunctions = await getUniqueWalletSetupFunctions(walletSetupDirPath);
  const cacheCreationPromises = await triggerCacheCreation(setupFunctions, downloadExtension, force);
  if (cacheCreationPromises.length === 0) {
    console.log("No new setup functions to cache. Exiting...");
    return;
  }
  await Promise.all(cacheCreationPromises);
  console.log("All wallet setup functions are now cached!");
}

// src/utils/bytesToMegabytes.ts
function bytesToMegabytes(bytes) {
  const megabytes = bytes / 1024 / 1024;
  return Math.round(megabytes * 10) / 10;
}

// src/utils/onDownloadProgress.ts
function onDownloadProgress(url, fileName) {
  let progressBar;
  let lastDownloadedBytes = 0;
  return ({ loaded: downloadedBytes, total: totalDownloadBytes }) => {
    if (!totalDownloadBytes) {
      throw new Error(
        `[DownloadFile] Request returned total download bytes as 0. This should never happen, and it means that the target file is empty. URL: ${url}`
      );
    }
    if (!progressBar) {
      progressBar = getDownloadProgressBar(url, fileName, totalDownloadBytes);
    } else {
      const delta = downloadedBytes - lastDownloadedBytes;
      lastDownloadedBytes = downloadedBytes;
      progressBar.tick(delta);
    }
  };
}
function getDownloadProgressBar(url, fileName, totalBytes) {
  const barHeader = url.startsWith("https://github.com/MetaMask/metamask-extension/releases/download/") ? "\u{1F98A} MetaMask" : fileName;
  const downloadSize = `${bytesToMegabytes(totalBytes)} MB`;
  return new ProgressBar(`${barHeader} (${downloadSize}) [:bar] :percent :etas`, {
    width: 20,
    complete: "=",
    incomplete: " ",
    total: totalBytes
  });
}

// src/downloadFile.ts
async function downloadFile(options) {
  const { url, outputDir, fileName, overrideFile } = options;
  const returnPromise = new Promise((resolve6, reject) => {
    const filePath = path5.join(outputDir, fileName);
    const fileExists = fs7.existsSync(filePath);
    if (fileExists && !overrideFile) {
      resolve6({
        filePath,
        downloadSkipped: true
      });
      return;
    }
    console.log(`[DEBUG] Downloading file from ${url}`);
    axios.get(url, {
      responseType: "stream",
      onDownloadProgress: onDownloadProgress(url, fileName)
    }).then((response) => {
      const writer = fs7.createWriteStream(filePath);
      response.data.pipe(writer);
      writer.on("finish", () => {
        resolve6({
          filePath,
          downloadSkipped: false
        });
      });
      writer.on("error", (error) => {
        reject(new Error(`[Writer] ${error.message}`));
      });
    }).catch((error) => {
      reject(new Error(`[Axios] ${error.message}`));
    });
  });
  return returnPromise.catch((error) => {
    throw new Error(`[DownloadFile] Error downloading the file - ${error.message}`);
  });
}
async function unzipArchive(options) {
  const { archivePath, overwrite } = options;
  const resultPromise = new Promise((resolve6, reject) => {
    const archiveFileExtension = archivePath.split(".").slice(-1);
    const outputPath = archivePath.replace(`.${archiveFileExtension}`, "");
    const fileExists = fs7.existsSync(outputPath);
    if (fileExists && !overwrite) {
      resolve6({
        outputPath,
        unzipSkipped: true
      });
      return;
    }
    fs7.mkdirSync(outputPath, { recursive: true });
    fs7.createReadStream(archivePath).pipe(unzippper.Parse()).on("entry", function(entry) {
      const fileName = entry.path;
      const type = entry.type;
      if (type === "Directory") {
        fs7.mkdirSync(path5.join(outputPath, fileName), { recursive: true });
        return;
      }
      if (type === "File") {
        const outputFilePath = path5.join(outputPath, fileName);
        const outputFilePathDir = path5.dirname(outputFilePath);
        if (!fs7.existsSync(outputFilePathDir)) {
          fs7.mkdirSync(outputFilePathDir, { recursive: true });
        }
        entry.pipe(fs7.createWriteStream(outputFilePath));
      }
    }).promise().then(() => {
      resolve6({
        outputPath,
        unzipSkipped: false
      });
    }).catch((error) => {
      fs7.unlinkSync(outputPath);
      reject(new Error(`[Pipe] ${error.message}`));
    });
  });
  return resultPromise.catch((error) => {
    throw new Error(`[UnzipFile] Error unzipping the file - ${error.message}`);
  });
}

// src/prepareExtension.ts
var DEFAULT_METAMASK_VERSION = "11.9.1";
var EXTENSION_DOWNLOAD_URL = `https://github.com/MetaMask/metamask-extension/releases/download/v${DEFAULT_METAMASK_VERSION}/metamask-chrome-${DEFAULT_METAMASK_VERSION}.zip`;
async function prepareExtension() {
  const cacheDirPath = ensureCacheDirExists();
  const downloadResult = await downloadFile({
    url: EXTENSION_DOWNLOAD_URL,
    outputDir: cacheDirPath,
    fileName: `metamask-chrome-${DEFAULT_METAMASK_VERSION}.zip`
  });
  const unzipResult = await unzipArchive({
    archivePath: downloadResult.filePath
  });
  return unzipResult.outputPath;
}

// src/cli/compilationFixes.ts
var DYNAMIC_REQUIRE_FS_FIX = `
// ---- DYNAMIC_REQUIRE_FS_FIX ----
var require = (await import("node:module")).createRequire(import.meta.url);
var __filename = (await import("node:url")).fileURLToPath(import.meta.url);
var __dirname = (await import("node:path")).dirname(__filename);
// ---- DYNAMIC_REQUIRE_FS_FIX ----
`.trim();
var FIXES_BANNER = `
/// ######## BANNER WITH FIXES START ########

${DYNAMIC_REQUIRE_FS_FIX}

/// ######## BANNER WITH FIXES END ########
`.trimStart();

// src/cli/compileWalletSetupFunctions.ts
var OUT_DIR_NAME = "wallet-setup-dist";
var createGlobPattern = (walletSetupDir) => path5.join(walletSetupDir, "**", "*.setup.{ts,js,mjs}");
async function compileWalletSetupFunctions(walletSetupDir, debug) {
  const outDir = path5.join(ensureCacheDirExists(), OUT_DIR_NAME);
  const globPattern = createGlobPattern(walletSetupDir);
  const fileList = await glob(globPattern);
  if (debug) {
    console.log("[DEBUG] Found the following wallet setup files:");
    console.log(fileList, "\n");
  }
  if (!fileList.length) {
    throw new Error(
      [
        `No wallet setup files found at ${walletSetupDir}`,
        "Remember that all wallet setup files must end with `.setup.{ts,js,mjs}` extension!"
      ].join("\n")
    );
  }
  await build({
    name: "cli-build",
    silent: true,
    entry: fileList,
    clean: true,
    outDir,
    format: "esm",
    splitting: true,
    sourcemap: false,
    config: false,
    // TODO: Make this list configurable.
    external: ["@synthetixio/synpress", "@playwright/test", "playwright-core", "esbuild", "tsup"],
    banner: {
      js: FIXES_BANNER
    },
    esbuildOptions(options) {
      options.drop = debug ? [] : ["console", "debugger"];
    }
  });
  return outDir;
}
var footerText = "Made with love by the Synpress team \u{1F49C}";
var footer = gradient("magenta", "cyan")(footerText);

// src/cli/cliEntrypoint.ts
var cliEntrypoint = async () => {
  console.log(`\u26A0\uFE0F ${chalk.yellowBright`The CLI is in alpha so expect breaking changes!`} \u26A0\uFE0F
`);
  const program = new Command().name(chalk.magenta("synpress")).description("A CLI for building the cache of wallet setup functions").argument("[dir]", "Directory containing the wallet setup functions", path5.join("test", WALLET_SETUP_DIR_NAME)).option(
    "--headless",
    "Build cache in the headless browser mode. Alternatively, set the `HEADLESS` env variable to `true`",
    false
  ).option("-f, --force", "Force the creation of cache even if it already exists", false).option("-d, --debug", "If this flag is present, the compilation files are not going to be deleted", false).helpOption(void 0, "Display help for command").addHelpText("afterAll", `
${footer}
`).parse(process.argv);
  let walletSetupDir = program.args[0];
  if (!walletSetupDir) {
    walletSetupDir = path5.join(process.cwd(), "test", WALLET_SETUP_DIR_NAME);
  }
  const flags = program.opts();
  if (flags.headless) {
    process.env.HEADLESS = true;
  }
  if (flags.debug) {
    console.log("[DEBUG] Running with the following options:");
    console.log({ cacheDir: walletSetupDir, ...flags, headless: Boolean(process.env.HEADLESS) ?? false }, "\n");
  }
  if (os.platform() === "win32") {
    console.log(
      [
        chalk.redBright("\u{1F6A8} Sorry, Windows is currently not supported. Please use WSL instead! \u{1F6A8}"),
        chalk.gray(
          "If you want to give it a crack over a hot cup of coffee and add Windows support yourself, please get in touch with the team on Discord so we can offer some guidance! \u{1F607}"
        )
      ].join("\n")
    );
    process.exit(1);
  }
  const compiledWalletSetupDirPath = await compileWalletSetupFunctions(walletSetupDir, flags.debug);
  await createCache(compiledWalletSetupDirPath, prepareExtension, flags.force);
  if (!flags.debug) {
    await rimraf(compiledWalletSetupDirPath);
  }
};

// src/cli/index.ts
cliEntrypoint().catch((err) => {
  console.log("Aborting...");
  if (err instanceof Error) {
    console.error(err);
  } else {
    console.error("Unknown error occurred!", err);
  }
  process.exit(1);
});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map